# Java 内存区域与内催溢出异常
### 运行时数据区域
#### 1. **程序计数器** （线程私有）
> 当前线程执行字节码的行号指示器，也是程序控制流的指示器。
> 
> Java多线程实现：通过线程轮流切换和分配处理器执行时间。
> 
> 如果正在执行Java方法，记录的的是字节码指令地址；如果执行的Native方法，则记录空。
> 
> 没有OOM异常。

#### 2. **Java虚拟机栈** （线程私有）
> 描述的是Java方法执行过程中的线程内存模型。
>
>每个方法在执行的时候都会创建一个栈帧，用于存储局部变量、操作数栈、动态链接、方法出口灯信息。
>
**局部变量表**：
> 存放着**Java基本数据类型**、**对象引用**、**returnAddress类型（指向一条字节码的指令地址）**。
>  
>  数据类型在变量表中以**局部变量槽**来表示。long和double占两个，其余占1个。
>
> 局部变量表所需空间在编译期间完成分配。
> 
> 如果线程请求的栈深度大于虚拟机允许的深度 StackOverflowError 
> 如果栈扩展无法申请到足够的内存 OOM
> Hotspot 不支持栈扩展 所以不会有OOM

#### 3.本地方法栈（线程私有）
> 基本等同于 Java虚拟机栈 区别就是 Java虚拟机栈执行Java方法，本地方法栈执行Native方法。
> Hotspot 直接将二者合二为一了。

#### 4.Java堆 （线程共享）
> 对象的实例基本都分配于此

#### 5.方法区 （线程共享）
> 实现方式存在差异  8之前为永久代 8之后为元空间

#### 6.运行时常量池
> 方法区的一部分
>  
>  class文件中的常量池表，用于存放编译期生成的各种字面量和符号引用，会在类加载之后放在运行时常量池。


### 对象的创建
>new关键字，遇到一条new字节码时，先检查这个指令的参数能否在常量池中定位到类的符号引用，以及这个符号代表的类是否以及加载，如果没有则先加载。
> 
>是否栈上分配（标量替换、逃逸分析）
>
>在堆上分配 碰撞指针（内存分布规则） 空闲列表（不规则） 选择哪种分配方式由GC算法的能力决定。如果带Compact（压缩）的如Serial、ParNew等就采用碰撞指针，如CMS 这种 Sweep 的收集器，就采用空闲列表 （当通过空闲列表拿到较大的一块内存时也会使用碰撞指针）
> 
> 保证线程安全提供了两种方案：1、CAS + 失败重试保证原子性 ； 2、如果启动的TLAB（线程本地缓冲区）,则优先分配到线程本地缓冲区。
> 
> 执行init 初始化对象

### 对象的内存分布

||
| --- | --- | --- |
|markword  | 4字节 |存放GC分代年龄、哈希码、锁标志、线程持有的锁、偏向线程ID、偏向时间戳|
|classpoint|  4字节|  执行 Class文件|
|实例数据|  | 分配顺序 long/double、ints、shorts/chars、bytes/booleans、oops
|占位| 补位 保证整体是8字节的整数倍| HotSpot 虚拟机自动内存管理系统要求对象起始地址必须是8字节的整数倍

### 对象的方位
#### 通过句柄池
> 堆上会划分出一块作为句柄池  引用中存储句柄地址
> 
> 句柄中包含了对象实例地址和Class文件（对象类型）地址
> a
> 优点：对象移动时只需要更改句柄中的实例数据指针。

#### 直接指针
> 引用中直接存储对象的地址
> 
> 优点：省略一次指针定位的的时间开销
